#include "world.h"

#include "viewer/viewer.h"
#include "rend/rend.h"
#include "occi_man/occi_man.h"
#include "key_man/key_man.h"
#include "util/vecs/vecs.h"

#define NODE_C          8

#define NO_HELD        -1

#define FAR             1000.f

#define MODE_2D         2
#define MODE_3D         3

struct wall {
        int             id      ;

        struct int2     edge    ;       // Indices in `world.edges` of edges.
        struct float2   angs    ;       // Relative (to viewer) angle to each
                                        // vertex of wall.
        struct float2   extent  ;       // Corresponds to x/y in edge, may not
                                        // be left/right. In radians relative
                                        // to viewer, bounded by FOV
        float           ext_i   ;       // Interval of extent.
                                        // Probably worth not storing this.
        float           dist    ;       // Distance to this wall.

        int             ckd     ;       // Already analysed on current
                                        // rendering pass.
};

#define BACKGROUND_VERTS        8       // Four corners and four midpoints.
#define BACKGROUND_IDXS         18      // Six vertices * three indices apiece.

static struct {
        struct int2    *edges   ;

        struct wall    *walls   ;

// Both removable in final version.
        int             v_held  ;
        int             mode    ;

        SDL_Vertex     *bg      ;
        int            *bg_idx  ;

        int            *wall_idx;       // Used for indexing vertices in render.
} world;

static SDL_Color vis_c  = { 30, 240, 45, 255 };
static SDL_Color held_c = { 60, 90, 240, 255 };

static void draw_seg_2d(
        int             w_ind   ,
        struct float2   seg
);

static void draw_seg_3d(
        int             w_ind   ,
        struct float2   seg
);

static int find_nr_w(
        float          *fr_than
);

void init_world(
        void
) {
        int id_c = 1;

        world.v_held = NO_HELD;
        world.mode = MODE_3D;

        world.wall_idx = calloc(6, sizeof(int));
        for (int i = 0; i < 6; ++i) {
                world.wall_idx[i] = i <= 3 ? i : i % 2 * 2;
        }

        world.bg = calloc(BACKGROUND_VERTS, sizeof(SDL_Vertex));
        struct float2 tr = { 0.f, 0.f };
        struct float2 a = { 0.5f, 0.f };
        float tmp;
        for (int i = 1; i < BACKGROUND_VERTS; ++i) {
                world.bg[i].position.x = tr.x;
                world.bg[i].position.y = tr.y;
                
                tmp = 255 * (tr.x == SCREEN_W / 2.f);
                log_msg("%f == %f ? %d", tr.x, SCREEN_W / 2.f, 255 * (tr.x == SCREEN_W / 2.f));
                world.bg[i].color.r = tmp;
                world.bg[i].color.g = tmp;
                world.bg[i].color.b = tmp;
                world.bg[i].color.a = 255;

                tr.x += a.x * SCREEN_W;
                tr.y += a.y * SCREEN_H;

                if (0 == i % 2 && i > 0) {
                        tmp = a.x;
                        a.x = a.y;
                        a.y = tmp;
                }

                if (4 == i) {
                        a.x *= -1;
                }
        }

        world.bg_idx = calloc(BACKGROUND_IDXS, sizeof(int));
// Corners.
        for (int i = 0; i < 4; ++i) {
                for (int j = 2 * i + 1; j < 2 * i + 3; ++j) {
                        world.bg_idx[i] = j % 8;
                }
        }
        for (int i = 0; i < 6; ++i) {
                world.bg_idx[i] = (2 * i + (i > 2 ? 5 : 7)) % 8;
        }

// Should all be coming from a file eventually.
        world.edges = calloc(NODE_C, sizeof(struct int2));
        world.walls = calloc(NODE_C, sizeof(struct wall));
        for (int i = 0; i < NODE_C / 2; ++i) {
                world.edges[i].x = (0 == i || 3 == i) ? 100 : SCREEN_W - 100;
                world.edges[i].y = (i >= 2) ? SCREEN_H - 100 : 100;

                world.walls[i].edge.x = i;
                world.walls[i].edge.y = (i + 1) % 4;

                world.walls[i].id = id_c++;
        }

        int ofi;
        for (int i = NODE_C / 2; i < NODE_C; ++i) {
                ofi = i % (NODE_C / 2);
                world.edges[i].x = (0 == ofi || 3 == ofi) ? 400 : 500;
                world.edges[i].y = (ofi >= 2) ? 300 : 200;

                world.walls[i].edge.x = ofi + 4;
                world.walls[i].edge.y = (ofi + 1) % 4 + 4;

                world.walls[i].id = id_c++;
        }

        recalc_world();

        init_occi_man();
}

void dest_world(
        void
) {
        dest_occi_man();

        free(world.bg);
        world.bg = NULL;

        free(world.bg_idx);
        world.bg_idx = NULL;

        free(world.wall_idx);
        world.wall_idx = NULL;

        free(world.edges);
        world.edges = NULL;

        free(world.walls);
        world.walls = NULL;
}

void update_world(
        void
) {
        SDL_Keycode k;
        int i = 0;

        while (-1 != (k = get_key(i++))) {
                switch (k) {
                case SDLK_3:
                        world.mode = MODE_3D;
                        break;
                case SDLK_2:
                        world.mode = MODE_2D;
                        break;
                default:
                        break;
                }
        }
}

void recalc_world(
        void
) {
        for (int w = 0; w < NODE_C; ++w) {      // Iterating over walls.
                if (
                        world.v_held == world.walls[w].edge.x
                     || world.v_held == world.walls[w].edge.y
                     || (       0.f == world.walls[w].ext_i
                             && !vx_in_view(
                                        world.edges[world.walls[w].edge.x],
                                        world.edges[world.walls[w].edge.y]
                                )
                        )
                ) {
                        continue;
                }

                calc_ext(
                        world.edges[world.walls[w].edge.x],
                        world.edges[world.walls[w].edge.y],
                        &world.walls[w].extent,
                        &world.walls[w].angs,
                        &world.walls[w].ext_i
                );

                world.walls[w].dist = rel_dist_ln(
                        world.edges[world.walls[w].edge.x],
                        world.edges[world.walls[w].edge.y]
                );
        }
}

void check_mclick(
        SDL_MouseButtonEvent    m
) {
        if (NO_HELD != world.v_held) {
                world.v_held = NO_HELD;
                update_world();
                return;
        }

        struct int2 v;
        for (int i = 0; i < NODE_C; ++i) {
                v = world.edges[i];
                if (v.x - 10 < m.x && v.x + 10 > m.x
                 && v.y - 10 < m.y && v.y + 10 > m.y) {
                        world.v_held = i;
                        return;
                }
        }
}

void check_mmove(
        SDL_MouseMotionEvent    m
) {
        if (NO_HELD == world.v_held) {
                return;
        }

        world.edges[world.v_held].x = m.x;
        world.edges[world.v_held].y = m.y;
}

static void draw_seg_2d(
        int             w_ind   ,
        struct float2   seg
) {
        struct int2 a1, a2;
        SDL_Color col = w_ind == world.v_held ? held_c : vis_c;

        points_on_line(
                world.edges[world.walls[w_ind].edge.x],
                world.edges[world.walls[w_ind].edge.y],
                seg, &a1, &a2
        );

        rend_ln(a1, a2, col);
}

static void draw_seg_3d(
        int             w_ind   ,
        struct float2   seg
) {
        struct int2 a1, a2;

        points_on_line(
                world.edges[world.walls[w_ind].edge.x],
                world.edges[world.walls[w_ind].edge.y],
                seg, &a1, &a2
        );

        float h1 = MIN(100.f + SCREEN_H / rel_dist_pt(a1) * 30.f, SCREEN_H);
        float h2 = MIN(100.f + SCREEN_H / rel_dist_pt(a2) * 30.f, SCREEN_H);

        SDL_Vertex *edges = calloc(4, sizeof(SDL_Vertex));
        float angc;
        float hc;
        float col;

//        SDL_Color col = {
//                world.edges[world.walls[w_ind].edge.x].x * 23 % 140 + 100,
//                world.edges[world.walls[w_ind].edge.y].y * 17 % 140 + 100,
//                (int)(w_ind) * 11 % 140 + 100,
//                255
//        };

        for (int v = 0; v < 4; ++v) {
                if (v % 3 == 0) {
                        angc = seg.x;
                        hc = h1;
                } else {
                        angc = seg.y;
                        hc = h2;
                }

                edges[v].position.x = l_on_vl(angc) * SCREEN_W;
                edges[v].position.y = get_los() + hc / 2.f * (v > 1 ? 1 : -1);

//                edges[v].color = col;
                
                col = (hc / SCREEN_H) * (hc / SCREEN_H) * 255;
                edges[v].color.r = col;
                edges[v].color.g = col;
                edges[v].color.b = col;
                edges[v].color.a = 255;
        }

        rend_gm(edges, 4, world.wall_idx, 6);

        free(edges);
        edges = NULL;
}

void draw_world(
        void
) {
        float nr = 0.f;
        int nr_w;

        struct float2  inter;   // Extent of wall within FOV.
        struct float2 *dr_segs; // Array of segments to draw as angle pairs.
        int drc;

        if (MODE_3D == world.mode) {
                rend_gm(world.bg, BACKGROUND_VERTS, world.bg_idx, BACKGROUND_IDXS);
        }

        for (int w = 0; w < NODE_C; ++w) {
                world.walls[w].ckd = FALSE;
        }

        ready_occi_man();

        while (!occi_closed() && -1 != (nr_w = find_nr_w(&nr))) {
                if (world.walls[nr_w].extent.x < world.walls[nr_w].extent.y) {
                        inter.x = world.walls[nr_w].extent.y;
                        inter.y = world.walls[nr_w].extent.x;
                } else {
                        inter.x = world.walls[nr_w].extent.x;
                        inter.y = world.walls[nr_w].extent.y;
                }

                drc = get_seg(inter, &dr_segs);

                for (int s = 0; s < drc; ++s) {
                        if (MODE_2D == world.mode) {
                                draw_seg_2d(nr_w, dr_segs[s]);
                        } else {
                                draw_seg_3d(nr_w, dr_segs[s]);
                        }
                }

                free(dr_segs);
                dr_segs = NULL;
        }
}

static int find_nr_w(
        float          *fr_than
) {
        int nearest = -1;
        float nr_than = FAR;
        float d;
        for (int i = 0; i < NODE_C; ++i) {
                if (0.f == world.walls[i].ext_i || world.walls[i].ckd) {
                        continue;
                }

                d = world.walls[i].dist;

                if (d < nr_than && d >= *fr_than) {
                        nearest = i;
                        nr_than = d;
                }
        }

        *fr_than = nr_than;
        world.walls[nearest].ckd = TRUE;
        return nearest;
}

int rq_move(
        struct float2   newp
) {
        struct float2 v1, v2;

        for (int w = 0; w < NODE_C; ++w) {
                v1.x = (float)world.edges[world.walls[w].edge.x].x;
                v1.y = (float)world.edges[world.walls[w].edge.x].y;

                v2.x = (float)world.edges[world.walls[w].edge.y].x;
                v2.y = (float)world.edges[world.walls[w].edge.y].y;

                float nr = dist_to_ln(v1, v2, newp);

                if (nr <= 5.f) {
                        return FALSE;
                }
        }

        return TRUE;
}
